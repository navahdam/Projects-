# Network Packet Sniffer with Real-Time Alert System and Integrated Firewall

# ---------------------------------------------------------------
# This Python script is a real-time network traffic sniffer that
# captures, analyzes, and logs packets. It includes:
# - A separate GUI to manage firewall rules (IP, Port, Protocol based)
# - Logging of allowed and blocked packets
# - Real-time alert system for blocked traffic via system tray
# - Integrated real-time graphing of packet activity
#
# Technologies used: PyQt5 for GUI, Scapy for packet sniffing, Matplotlib for plotting

import sys
import os
import json
import csv
import threading
from datetime import datetime
from collections import deque, Counter
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas, NavigationToolbar2QT as NavigationToolbar
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel, QHBoxLayout,
    QPushButton, QLineEdit, QHeaderView, QMessageBox,
    QSystemTrayIcon, QStyle, QComboBox, QListWidget, QListWidgetItem
)
from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QIcon
import matplotlib.gridspec as gridspec
from scapy.all import sniff, IP, TCP, UDP, ICMP

FIREWALL_RULES_FILE = "firewall_rules.json"
BLOCKED_LOG_FILE = "blocked_packets.csv"
PACKET_LOG_FILE = "packet_log.csv"

blocked_ips = set()
blocked_ports = set()
blocked_protocols = set()

time_labels = deque(maxlen=300)
allowed_counts = deque(maxlen=300)
blocked_counts = deque(maxlen=300)
protocol_counter = Counter()

main_window = None


def load_firewall_rules():
    global blocked_ips, blocked_ports, blocked_protocols
    default_ips = {"192.168.1.10"}
    default_ports = {"22", "445"}
    default_protocols = {"ICMP"}
    if os.path.exists(FIREWALL_RULES_FILE):
        try:
            with open(FIREWALL_RULES_FILE, "r") as f:
                data = json.load(f)
                blocked_ips.update(data.get("ips", []))
                blocked_ports.update(data.get("ports", []))
                blocked_protocols.update(data.get("protocols", []))
        except Exception:
            pass
    if not (blocked_ips or blocked_ports or blocked_protocols):
        blocked_ips.update(default_ips)
        blocked_ports.update(default_ports)
        blocked_protocols.update(default_protocols)
        save_firewall_rules()


def save_firewall_rules():
    rules = {
        "ips": list(blocked_ips),
        "ports": list(blocked_ports),
        "protocols": list(blocked_protocols)
    }
    with open(FIREWALL_RULES_FILE, "w") as f:
        json.dump(rules, f, indent=4)


class FirewallControlGUI(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Firewall Control Panel")
        self.setGeometry(300, 300, 500, 400)
        layout = QVBoxLayout()

        form = QHBoxLayout()
        self.ip_input = QLineEdit()
        self.ip_input.setPlaceholderText("Block IP")
        self.port_input = QLineEdit()
        self.port_input.setPlaceholderText("Block Port")
        self.proto_input = QLineEdit()
        self.proto_input.setPlaceholderText("Block Protocol")
        form.addWidget(self.ip_input)
        form.addWidget(self.port_input)
        form.addWidget(self.proto_input)
        layout.addLayout(form)

        btns = QHBoxLayout()
        self.add_rule_btn = QPushButton("Add Rule")
        self.del_rule_btn = QPushButton("Delete Rule")
        btns.addWidget(self.add_rule_btn)
        btns.addWidget(self.del_rule_btn)
        layout.addLayout(btns)

        self.rule_list = QListWidget()
        layout.addWidget(QLabel("Active Firewall Rules:"))
        layout.addWidget(self.rule_list)

        self.setLayout(layout)

        self.add_rule_btn.clicked.connect(self.add_rule)
        self.del_rule_btn.clicked.connect(self.delete_rule)

        self.refresh_rule_list()

    def add_rule(self):
        ip = self.ip_input.text().strip()
        port = self.port_input.text().strip()
        proto = self.proto_input.text().strip().upper()
        if ip:
            blocked_ips.add(ip)
        if port:
            blocked_ports.add(port)
        if proto:
            blocked_protocols.add(proto)
        save_firewall_rules()
        self.refresh_rule_list()

    def delete_rule(self):
        selected = self.rule_list.selectedItems()
        for item in selected:
            rule = item.text()
            if rule.startswith("IP:"):
                blocked_ips.discard(rule[3:].strip())
            elif rule.startswith("Port:"):
                blocked_ports.discard(rule[5:].strip())
            elif rule.startswith("Proto:"):
                blocked_protocols.discard(rule[6:].strip())
        save_firewall_rules()
        self.refresh_rule_list()

    def refresh_rule_list(self):
        self.rule_list.clear()
        for ip in blocked_ips:
            self.rule_list.addItem(QListWidgetItem(f"IP: {ip}"))
        for port in blocked_ports:
            self.rule_list.addItem(QListWidgetItem(f"Port: {port}"))
        for proto in blocked_protocols:
            self.rule_list.addItem(QListWidgetItem(f"Proto: {proto}"))


class GraphMonitorGUI(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Packet Monitor - Graphs")
        self.setGeometry(200, 200, 900, 700)

        layout = QVBoxLayout()

        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setIcon(self.style().standardIcon(QStyle.SP_ComputerIcon))
        self.tray_icon.show()

        controls = QHBoxLayout()
        self.combo = QComboBox()
        self.combo.addItems(["Line Graph", "Bar Graph"])
        self.combo.currentIndexChanged.connect(self.update_graphs)

        self.refresh_btn = QPushButton("Refresh Graph")
        self.refresh_btn.clicked.connect(self.update_graphs)

        self.fw_btn = QPushButton("Firewall Controls")
        self.fw_btn.clicked.connect(self.launch_firewall_gui)

        controls.addWidget(QLabel("Graph Type:"))
        controls.addWidget(self.combo)
        controls.addWidget(self.refresh_btn)
        controls.addWidget(self.fw_btn)
        layout.addLayout(controls)

        self.figure = plt.figure(figsize=(12, 6))
        gs = gridspec.GridSpec(3, 2)
        self.ax1 = self.figure.add_subplot(gs[0:2, :])
        self.ax2 = self.figure.add_subplot(gs[2, 0])
        self.ax3 = self.figure.add_subplot(gs[2, 1])
        self.canvas = FigureCanvas(self.figure)
        self.toolbar = NavigationToolbar(self.canvas, self)
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        self.setLayout(layout)

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_graphs)
        self.timer.start(2000)

    def launch_firewall_gui(self):
        self.fw_window = FirewallControlGUI()
        self.fw_window.show()

    def update_graphs(self):
        self.ax1.clear()
        self.ax2.clear()
        self.ax3.clear()
        short_times = [t[-8:] for t in time_labels]
        spacing = max(1, len(short_times) // 8)
        xticks = list(range(0, len(short_times), spacing))
        graph_type = self.combo.currentText()

        if graph_type == "Line Graph":
            self.ax1.plot(short_times, allowed_counts, label="Allowed", color="green", marker="o")
            self.ax1.plot(short_times, blocked_counts, label="Blocked", color="red", marker="x")
        else:
            self.ax1.bar(short_times, allowed_counts, label="Allowed", color="green")
            self.ax1.bar(short_times, blocked_counts, label="Blocked", color="red", alpha=0.5)

        self.ax1.set_title("Packet Activity Over Time")
        self.ax1.set_xlabel("Time")
        self.ax1.set_ylabel("Count")
        self.ax1.set_xticks(xticks)
        self.ax1.set_xticklabels([short_times[i] for i in xticks], rotation=45, ha="right")
        self.ax1.legend()
        self.ax1.grid(True)

        if protocol_counter:
            labels, values = zip(*protocol_counter.items())
            colors = plt.cm.Set3(range(len(labels)))
            self.ax2.pie(values, labels=labels, autopct='%1.1f%%', colors=colors, startangle=140)
            self.ax2.set_title("Protocol Distribution")
            self.ax2.axis('equal')

        total_packets = sum(allowed_counts) + sum(blocked_counts)
        blocked_pct = (sum(blocked_counts) / total_packets) * 100 if total_packets else 0
        top_proto = protocol_counter.most_common(1)[0][0] if protocol_counter else "N/A"
        stats = f"Total Packets: {total_packets}\nBlocked %: {blocked_pct:.2f}%\nTop Protocol: {top_proto}"
        self.ax3.axis("off")
        self.ax3.text(0, 1, stats, va="top", ha="left", fontsize=12)

        self.canvas.draw()

    def show_alert(self, msg):
        self.tray_icon.showMessage("Firewall Alert", msg, QSystemTrayIcon.Warning)


def packet_callback(pkt):
    if IP in pkt:
        src_ip = pkt[IP].src
        dst_ip = pkt[IP].dst
        proto = pkt.proto
        proto_name = {1: "ICMP", 6: "TCP", 17: "UDP"}.get(proto, str(proto))
        dst_port = str(pkt[TCP].dport) if TCP in pkt else str(pkt[UDP].dport) if UDP in pkt else ""
        src_port = str(pkt[TCP].sport) if TCP in pkt else str(pkt[UDP].sport) if UDP in pkt else ""
        timestamp = datetime.now().strftime("%H:%M:%S")

        time_labels.append(timestamp)
        protocol_counter[proto_name] += 1

        file_exists = os.path.exists(PACKET_LOG_FILE)
        with open(PACKET_LOG_FILE, mode='a', newline='') as packet_file:
            writer = csv.writer(packet_file)
            if not file_exists:
                writer.writerow(["Timestamp", "Source IP", "Source Port", "Destination IP", "Destination Port", "Protocol"])
            writer.writerow([timestamp, src_ip, src_port, dst_ip, dst_port, proto_name])

        if (src_ip in blocked_ips or dst_port in blocked_ports or proto_name in blocked_protocols):
            blocked_counts.append(blocked_counts[-1] + 1 if blocked_counts else 1)
            allowed_counts.append(allowed_counts[-1] if allowed_counts else 0)
            with open(BLOCKED_LOG_FILE, mode='a', newline='') as log_file:
                writer = csv.writer(log_file)
                if log_file.tell() == 0:
                    writer.writerow(["Timestamp", "Source IP", "Destination Port", "Protocol"])
                writer.writerow([timestamp, src_ip, dst_port, proto_name])

            print(f"[BLOCKED] {src_ip} -> {dst_ip}:{dst_port} [{proto_name}]")
            if main_window:
                QTimer.singleShot(0, lambda: main_window.show_alert(f"Blocked: {src_ip} → {dst_ip}:{dst_port} [{proto_name}]"))
        else:
            blocked_counts.append(blocked_counts[-1] if blocked_counts else 0)
            allowed_counts.append(allowed_counts[-1] + 1 if allowed_counts else 1)
            print(f"[ALLOWED] {src_ip}:{src_port} -> {dst_ip}:{dst_port} [{proto_name}]")


def start_sniffer():
    print("[INFO] Starting packet sniffer...")
    sniff(prn=packet_callback, store=0)


if __name__ == "__main__":
    load_firewall_rules()
    sniffer_thread = threading.Thread(target=start_sniffer, daemon=True)
    sniffer_thread.start()
    app = QApplication(sys.argv)
    main_window = GraphMonitorGUI()
    main_window.show()
    sys.exit(app.exec_())
