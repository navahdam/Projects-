# Network Packet Sniffer with Real-Time Alert System and Integrated Firewall

# ---------------------------------------------------------------
# This Python script is a real-time network traffic sniffer that
# captures, analyzes, and logs packets. It includes:
# - A separate GUI to manage firewall rules (IP, Port, Protocol based)
# - Logging of allowed and blocked packets
# - Real-time alert system for blocked traffic via system tray
# - Integrated real-time graphing of packet activity
#
# Technologies used: PyQt5 for GUI, Scapy for packet sniffing, Matplotlib for plotting

import sys
import os
import json
import csv
import threading
from datetime import datetime
from collections import deque, Counter
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas, NavigationToolbar2QT as NavigationToolbar
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel, QHBoxLayout,
    QPushButton, QLineEdit, QHeaderView, QMessageBox,
    QSystemTrayIcon, QStyle, QComboBox, QListWidget, QListWidgetItem
)
from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QIcon
import matplotlib.gridspec as gridspec
from scapy.all import sniff, IP, TCP, UDP, ICMP

# File paths for firewall rules and packet logs
FIREWALL_RULES_FILE = "firewall_rules.json"
BLOCKED_LOG_FILE = "blocked_packets.csv"
PACKET_LOG_FILE = "packet_log.csv"

# Sets for blocked IPs, ports, and protocols
blocked_ips = set()
blocked_ports = set()
blocked_protocols = set()

# Deques to hold data for plotting
time_labels = deque(maxlen=300)
allowed_counts = deque(maxlen=300)
blocked_counts = deque(maxlen=300)
protocol_counter = Counter()

main_window = None

# Load saved firewall rules or initialize default ones
def load_firewall_rules():
    global blocked_ips, blocked_ports, blocked_protocols
    default_ips = {"192.168.1.10"}
    default_ports = {"22", "445"}
    default_protocols = {"ICMP"}
    if os.path.exists(FIREWALL_RULES_FILE):
        try:
            with open(FIREWALL_RULES_FILE, "r") as f:
                data = json.load(f)
                blocked_ips.update(data.get("ips", []))
                blocked_ports.update(data.get("ports", []))
                blocked_protocols.update(data.get("protocols", []))
        except Exception:
            pass
    if not (blocked_ips or blocked_ports or blocked_protocols):
        blocked_ips.update(default_ips)
        blocked_ports.update(default_ports)
        blocked_protocols.update(default_protocols)
        save_firewall_rules()

# Save current firewall rules to file
def save_firewall_rules():
    rules = {
        "ips": list(blocked_ips),
        "ports": list(blocked_ports),
        "protocols": list(blocked_protocols)
    }
    with open(FIREWALL_RULES_FILE, "w") as f:
        json.dump(rules, f, indent=4)

# Firewall control window for managing rules
class FirewallControlGUI(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Firewall Control Panel")
        self.setGeometry(300, 300, 500, 400)
        layout = QVBoxLayout()

        # Input fields for new rules
        form = QHBoxLayout()
        self.ip_input = QLineEdit()
        self.ip_input.setPlaceholderText("Block IP")
        self.port_input = QLineEdit()
        self.port_input.setPlaceholderText("Block Port")
        self.proto_input = QLineEdit()
        self.proto_input.setPlaceholderText("Block Protocol")
        form.addWidget(self.ip_input)
        form.addWidget(self.port_input)
        form.addWidget(self.proto_input)
        layout.addLayout(form)

        # Buttons to add or delete rules
        btns = QHBoxLayout()
        self.add_rule_btn = QPushButton("Add Rule")
        self.del_rule_btn = QPushButton("Delete Rule")
        btns.addWidget(self.add_rule_btn)
        btns.addWidget(self.del_rule_btn)
        layout.addLayout(btns)

        # Display of current active rules
        self.rule_list = QListWidget()
        layout.addWidget(QLabel("Active Firewall Rules:"))
        layout.addWidget(self.rule_list)

        self.setLayout(layout)

        self.add_rule_btn.clicked.connect(self.add_rule)
        self.del_rule_btn.clicked.connect(self.delete_rule)

        self.refresh_rule_list()

    # Add new rule to appropriate set
    def add_rule(self):
        ip = self.ip_input.text().strip()
        port = self.port_input.text().strip()
        proto = self.proto_input.text().strip().upper()
        if ip:
            blocked_ips.add(ip)
        if port:
            blocked_ports.add(port)
        if proto:
            blocked_protocols.add(proto)
        save_firewall_rules()
        self.refresh_rule_list()

    # Delete selected rule from set
    def delete_rule(self):
        selected = self.rule_list.selectedItems()
        for item in selected:
            rule = item.text()
            if rule.startswith("IP:"):
                blocked_ips.discard(rule[3:].strip())
            elif rule.startswith("Port:"):
                blocked_ports.discard(rule[5:].strip())
            elif rule.startswith("Proto:"):
                blocked_protocols.discard(rule[6:].strip())
        save_firewall_rules()
        self.refresh_rule_list()

    # Refresh the rule list UI display
    def refresh_rule_list(self):
        self.rule_list.clear()
        for ip in blocked_ips:
            self.rule_list.addItem(QListWidgetItem(f"IP: {ip}"))
        for port in blocked_ports:
            self.rule_list.addItem(QListWidgetItem(f"Port: {port}"))
        for proto in blocked_protocols:
            self.rule_list.addItem(QListWidgetItem(f"Proto: {proto}"))

# Main window that displays graphs and alerts
class GraphMonitorGUI(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Packet Monitor - Graphs")
        self.setGeometry(200, 200, 900, 700)

        layout = QVBoxLayout()

        # System tray alert icon
        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setIcon(self.style().standardIcon(QStyle.SP_ComputerIcon))
        self.tray_icon.show()

        # Top controls: graph type selector, refresh, firewall GUI
        controls = QHBoxLayout()
        self.combo = QComboBox()
        self.combo.addItems(["Line Graph", "Bar Graph"])
        self.combo.currentIndexChanged.connect(self.update_graphs)

        self.refresh_btn = QPushButton("Refresh Graph")
        self.refresh_btn.clicked.connect(self.update_graphs)

        self.fw_btn = QPushButton("Firewall Controls")
        self.fw_btn.clicked.connect(self.launch_firewall_gui)

        controls.addWidget(QLabel("Graph Type:"))
        controls.addWidget(self.combo)
        controls.addWidget(self.refresh_btn)
        controls.addWidget(self.fw_btn)
        layout.addLayout(controls)

        # Graph area setup
        self.figure = plt.figure(figsize=(12, 6))
        gs = gridspec.GridSpec(3, 2)
        self.ax1 = self.figure.add_subplot(gs[0:2, :])
        self.ax2 = self.figure.add_subplot(gs[2, 0])
        self.ax3 = self.figure.add_subplot(gs[2, 1])
        self.canvas = FigureCanvas(self.figure)
        self.toolbar = NavigationToolbar(self.canvas, self)
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        self.setLayout(layout)

        # Auto-refresh timer for graphs
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_graphs)
        self.timer.start(2000)

    # Open the firewall control window
    def launch_firewall_gui(self):
        self.fw_window = FirewallControlGUI()
        self.fw_window.show()

    # Draw and update all graphs in GUI
    def update_graphs(self):
        self.ax1.clear()
        self.ax2.clear()
        self.ax3.clear()
        short_times = [t[-8:] for t in time_labels]
        spacing = max(1, len(short_times) // 8)
        xticks = list(range(0, len(short_times), spacing))
        graph_type = self.combo.currentText()

        if graph_type == "Line Graph":
            self.ax1.plot(short_times, allowed_counts, label="Allowed", color="green", marker="o")
            self.ax1.plot(short_times, blocked_counts, label="Blocked", color="red", marker="x")
        else:
            self.ax1.bar(short_times, allowed_counts, label="Allowed", color="green")
            self.ax1.bar(short_times, blocked_counts, label="Blocked", color="red", alpha=0.5)

        self.ax1.set_title("Packet Activity Over Time")
        self.ax1.set_xlabel("Time")
        self.ax1.set_ylabel("Count")
        self.ax1.set_xticks(xticks)
        self.ax1.set_xticklabels([short_times[i] for i in xticks], rotation=45, ha="right")
        self.ax1.legend()
        self.ax1.grid(True)

        if protocol_counter:
            labels, values = zip(*protocol_counter.items())
            colors = plt.cm.Set3(range(len(labels)))
            self.ax2.pie(values, labels=labels, autopct='%1.1f%%', colors=colors, startangle=140)
            self.ax2.set_title("Protocol Distribution")
            self.ax2.axis('equal')

        total_packets = sum(allowed_counts) + sum(blocked_counts)
        blocked_pct = (sum(blocked_counts) / total_packets) * 100 if total_packets else 0
        top_proto = protocol_counter.most_common(1)[0][0] if protocol_counter else "N/A"
        stats = f"Total Packets: {total_packets}\nBlocked %: {blocked_pct:.2f}%\nTop Protocol: {top_proto}"
        self.ax3.axis("off")
        self.ax3.text(0, 1, stats, va="top", ha="left", fontsize=12)

        self.canvas.draw()

    # Trigger system tray notification
    def show_alert(self, msg):
        self.tray_icon.showMessage("Firewall Alert", msg, QSystemTrayIcon.Warning)

# Analyze each captured packet and apply firewall rules
def packet_callback(pkt):
    if IP in pkt:
        src_ip = pkt[IP].src
        dst_ip = pkt[IP].dst
        proto = pkt.proto
        proto_name = {1: "ICMP", 6: "TCP", 17: "UDP"}.get(proto, str(proto))
        dst_port = str(pkt[TCP].dport) if TCP in pkt else str(pkt[UDP].dport) if UDP in pkt else ""
        src_port = str(pkt[TCP].sport) if TCP in pkt else str(pkt[UDP].sport) if UDP in pkt else ""
        timestamp = datetime.now().strftime("%H:%M:%S")

        time_labels.append(timestamp)
        protocol_counter[proto_name] += 1

        file_exists = os.path.exists(PACKET_LOG_FILE)
        with open(PACKET_LOG_FILE, mode='a', newline='') as packet_file:
            writer = csv.writer(packet_file)
            if not file_exists:
                writer.writerow(["Timestamp", "Source IP", "Source Port", "Destination IP", "Destination Port", "Protocol"])
            writer.writerow([timestamp, src_ip, src_port, dst_ip, dst_port, proto_name])

        if (src_ip in blocked_ips or dst_port in blocked_ports or proto_name in blocked_protocols):
            blocked_counts.append(blocked_counts[-1] + 1 if blocked_counts else 1)
            allowed_counts.append(allowed_counts[-1] if allowed_counts else 0)
            with open(BLOCKED_LOG_FILE, mode='a', newline='') as log_file:
                writer = csv.writer(log_file)
                if log_file.tell() == 0:
                    writer.writerow(["Timestamp", "Source IP", "Destination Port", "Protocol"])
                writer.writerow([timestamp, src_ip, dst_port, proto_name])

            print(f"[BLOCKED] {src_ip} -> {dst_ip}:{dst_port} [{proto_name}]")
            if main_window:
                QTimer.singleShot(0, lambda: main_window.show_alert(f"Blocked: {src_ip} â†’ {dst_ip}:{dst_port} [{proto_name}]"))
        else:
            blocked_counts.append(blocked_counts[-1] if blocked_counts else 0)
            allowed_counts.append(allowed_counts[-1] + 1 if allowed_counts else 1)
            print(f"[ALLOWED] {src_ip}:{src_port} -> {dst_ip}:{dst_port} [{proto_name}]")

# Background thread to capture packets

def start_sniffer():
    print("[INFO] Starting packet sniffer...")
    sniff(prn=packet_callback, store=0)

# Main application entry point
if __name__ == "__main__":
    load_firewall_rules()
    sniffer_thread = threading.Thread(target=start_sniffer, daemon=True)
    sniffer_thread.start()
    app = QApplication(sys.argv)
    main_window = GraphMonitorGUI()
    main_window.show()
    sys.exit(app.exec_())
